<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Always_place_opens_at_top_level" xml:space="preserve">
    <value>Open ステートメントを常に最上位に配置する</value>
  </data>
  <data name="CodeLens" xml:space="preserve">
    <value>CodeLens</value>
  </data>
  <data name="CodeLens_Replace_LineLens" xml:space="preserve">
    <value>注釈を行の上ではなく右に表示する</value>
  </data>
  <data name="CodeLens_Switch" xml:space="preserve">
    <value>CodeLens を有効にする (試験段階)</value>
  </data>
  <data name="CodeLens_Prefix" xml:space="preserve">
    <value>注釈のプレフィックス</value>
  </data>
  <data name="CodeLens_UseColors" xml:space="preserve">
    <value>注釈でカラーを使用する</value>
  </data>
  <data name="Code_Fixes" xml:space="preserve">
    <value>コード修正</value>
  </data>
  <data name="Completion_Lists" xml:space="preserve">
    <value>入力候補一覧</value>
  </data>
  <data name="Language_Service_Performance" xml:space="preserve">
    <value>パフォーマンス</value>
  </data>
  <data name="Dash_underline" xml:space="preserve">
    <value>破線の下線(_A)</value>
  </data>
  <data name="Dot_underline" xml:space="preserve">
    <value>点線の下線(_O)</value>
  </data>
  <data name="Navigation_links" xml:space="preserve">
    <value>ナビゲーション リンク</value>
  </data>
  <data name="Show_all_symbols" xml:space="preserve">
    <value>開かれていない名前空間の記号を表示する(_Y)</value>
  </data>
  <data name="Show_completion_list_after_a_character_is_deleted" xml:space="preserve">
    <value>文字が削除された後に入力候補一覧を表示する(_D)</value>
  </data>
  <data name="Show_completion_list_after_a_character_is_typed" xml:space="preserve">
    <value>文字が入力された後に入力候補一覧を表示する(_S)</value>
  </data>
  <data name="Enable_in_memory_cross_project_references" xml:space="preserve">
    <value>メモリ内のプロジェクト間参照を有効にする(_E)</value>
  </data>
  <data name="Project_check_cache_size" xml:space="preserve">
    <value>データがメモリ内にキャッシュされているプロジェクトの数</value>
  </data>
  <data name="Show_navigation_links_as" xml:space="preserve">
    <value>次としてナビゲーション リンクを表示する(_H)</value>
  </data>
  <data name="Simplify_name_code_fix" xml:space="preserve">
    <value>名前の簡略化する (不要な修飾子の削除)</value>
  </data>
  <data name="Solid_underline" xml:space="preserve">
    <value>実線の下線(_S)</value>
  </data>
  <data name="Unused_opens_code_fix" xml:space="preserve">
    <value>未使用の Open ステートメントを削除する</value>
  </data>
  <data name="Unused_declaration_code_fix" xml:space="preserve">
    <value>未使用の値を分析して修正を提案する</value>
  </data>
  <data name="Block_Structure" xml:space="preserve">
    <value>ブロック構造のガイド</value>
  </data>
  <data name="Show_guides" xml:space="preserve">
    <value>F# コードの構造のガイドラインを表示する</value>
  </data>
  <data name="Outlining" xml:space="preserve">
    <value>アウトライン</value>
  </data>
  <data name="Show_Outlining" xml:space="preserve">
    <value>F# コードのアウトラインおよび折りたたみ可能なノードを表示する</value>
  </data>
  <data name="Time_until_stale_completion" xml:space="preserve">
    <value>古い結果が使用されるまでの時間 (ミリ秒)</value>
  </data>
  <data name="IntelliSense_Performance" xml:space="preserve">
    <value>IntelliSense のパフォーマンス オプション</value>
  </data>
  <data name="Project_Performance" xml:space="preserve">
    <value>F# プロジェクトとキャッシュのパフォーマンス オプション</value>
  </data>
  <data name="Enable_Stale_IntelliSense_Results" xml:space="preserve">
    <value>IntelliSense 機能に対して古いデータを有効にする</value>
  </data>
  <data name="Tooltip_in_memory_cross_project_references" xml:space="preserve">
    <value>メモリ内のプロジェクト間参照に、プロジェクトをまたいで IDE 機能を動作可能にするプロジェクト レベルのデータが格納されます。</value>
  </data>
  <data name="Tooltip_project_check_cache_size" xml:space="preserve">
    <value>IDE 機能のためにプロジェクト データがキャッシュされます。値を高くすると、キャッシュされるプロジェクトが多くなるため、メモリ使用量が増えます。この値の調整は、小規模または中規模のソリューションに影響しません。</value>
  </data>
  <data name="Enter_key_always" xml:space="preserve">
    <value>Enter を押すと常に新しい行を追加します</value>
  </data>
  <data name="Enter_key_never" xml:space="preserve">
    <value>Enter 時に新しい行を追加しません</value>
  </data>
  <data name="Enter_key_only" xml:space="preserve">
    <value>単語を完全に入力した後 Enter キーで新しい行のみを追加する</value>
  </data>
  <data name="Enter_Key_Rule" xml:space="preserve">
    <value>Enter キー入力時動作</value>
  </data>
  <data name="Format_on_paste" xml:space="preserve">
    <value>貼り付け時にインデントを再フォーマットする</value>
  </data>
  <data name="Suggest_names_for_errors_code_fix" xml:space="preserve">
    <value>未解決の識別子の名前を提案します</value>
  </data>
  <data name="Text_hover" xml:space="preserve">
    <value>テキスト ホバー</value>
  </data>
  <data name="Diagnostics" xml:space="preserve">
    <value>診断</value>
  </data>
</root>