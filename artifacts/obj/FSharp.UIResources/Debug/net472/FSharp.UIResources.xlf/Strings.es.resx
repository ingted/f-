<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Always_place_opens_at_top_level" xml:space="preserve">
    <value>Colocar siempre las instrucciones open en el nivel superior</value>
  </data>
  <data name="CodeLens" xml:space="preserve">
    <value>CodeLens</value>
  </data>
  <data name="CodeLens_Replace_LineLens" xml:space="preserve">
    <value>Mostrar anotaciones a la derecha en lugar de encima de la línea</value>
  </data>
  <data name="CodeLens_Switch" xml:space="preserve">
    <value>Habilitar CodeLens (experimental)</value>
  </data>
  <data name="CodeLens_Prefix" xml:space="preserve">
    <value>Prefijo de anotación</value>
  </data>
  <data name="CodeLens_UseColors" xml:space="preserve">
    <value>Usar colores en anotaciones</value>
  </data>
  <data name="Code_Fixes" xml:space="preserve">
    <value>Correcciones de código</value>
  </data>
  <data name="Completion_Lists" xml:space="preserve">
    <value>Listas de finalización</value>
  </data>
  <data name="Language_Service_Performance" xml:space="preserve">
    <value>Rendimiento</value>
  </data>
  <data name="Dash_underline" xml:space="preserve">
    <value>_Subrayado guion</value>
  </data>
  <data name="Dot_underline" xml:space="preserve">
    <value>S_ubrayado punto</value>
  </data>
  <data name="Navigation_links" xml:space="preserve">
    <value>Vínculos de navegación</value>
  </data>
  <data name="Show_all_symbols" xml:space="preserve">
    <value>Mostrar sím_bolos en espacios de nombres sin abrir</value>
  </data>
  <data name="Show_completion_list_after_a_character_is_deleted" xml:space="preserve">
    <value>Mostrar lista de finalización después de _eliminar un carácter</value>
  </data>
  <data name="Show_completion_list_after_a_character_is_typed" xml:space="preserve">
    <value>_Mostrar lista de finalización después de escribir un carácter</value>
  </data>
  <data name="Enable_in_memory_cross_project_references" xml:space="preserve">
    <value>_Habilitar referencias entre proyectos en memoria</value>
  </data>
  <data name="Project_check_cache_size" xml:space="preserve">
    <value>Número de proyectos cuyos datos se almacenan en la memoria caché</value>
  </data>
  <data name="Show_navigation_links_as" xml:space="preserve">
    <value>M_ostrar vínculos de navegación como</value>
  </data>
  <data name="Simplify_name_code_fix" xml:space="preserve">
    <value>Simplificar nombres (quitar calificadores innecesarios)</value>
  </data>
  <data name="Solid_underline" xml:space="preserve">
    <value>Su_brayado sólido</value>
  </data>
  <data name="Unused_opens_code_fix" xml:space="preserve">
    <value>Quitar instrucciones open no usadas</value>
  </data>
  <data name="Unused_declaration_code_fix" xml:space="preserve">
    <value>Analizar y sugerir correcciones para valores no utilizados</value>
  </data>
  <data name="Block_Structure" xml:space="preserve">
    <value>Guías de estructura de bloque</value>
  </data>
  <data name="Show_guides" xml:space="preserve">
    <value>Mostrar las guías de la estructura del código F#</value>
  </data>
  <data name="Outlining" xml:space="preserve">
    <value>Esquematización</value>
  </data>
  <data name="Show_Outlining" xml:space="preserve">
    <value>Mostrar los nodos de esquematización y contraíbles del código de F#</value>
  </data>
  <data name="Time_until_stale_completion" xml:space="preserve">
    <value>Tiempo hasta que se utilizan los resultados obsoletos (en milisegundos)</value>
  </data>
  <data name="IntelliSense_Performance" xml:space="preserve">
    <value>Opciones de rendimiento de IntelliSense</value>
  </data>
  <data name="Project_Performance" xml:space="preserve">
    <value>Opciones de rendimiento de almacenamiento en caché y proyectos de F#</value>
  </data>
  <data name="Enable_Stale_IntelliSense_Results" xml:space="preserve">
    <value>Habilitar datos obsoletos para características de IntelliSense</value>
  </data>
  <data name="Tooltip_in_memory_cross_project_references" xml:space="preserve">
    <value>Las referencias en memoria entre proyectos almacenan los datos de nivel de proyecto en memoria para permitir que las características del IDE funcionen de unos proyectos a otros.</value>
  </data>
  <data name="Tooltip_project_check_cache_size" xml:space="preserve">
    <value>Los datos de proyecto se almacenan en caché para que funcionen las características del IDE. Los valores más altos utilizan más memoria porque se almacenan en caché más proyectos. El ajuste de este valor no debería afectar a soluciones de tamaño pequeño o medio.</value>
  </data>
  <data name="Enter_key_always" xml:space="preserve">
    <value>Siempre agregar una nueva línea al pulsar Intro</value>
  </data>
  <data name="Enter_key_never" xml:space="preserve">
    <value>Nunca agregar una nueva línea al pulsar Intro</value>
  </data>
  <data name="Enter_key_only" xml:space="preserve">
    <value>Solo agregar una nueva línea al pulsar Intro cuando se haya terminado de escribir completamente una palabra</value>
  </data>
  <data name="Enter_Key_Rule" xml:space="preserve">
    <value>Comportamiento de la tecla Intro</value>
  </data>
  <data name="Format_on_paste" xml:space="preserve">
    <value>Cambiar formato de sangría al pegar</value>
  </data>
  <data name="Suggest_names_for_errors_code_fix" xml:space="preserve">
    <value>Sugerir nombres para los identificadores no resueltos</value>
  </data>
  <data name="Text_hover" xml:space="preserve">
    <value>Texto al pasar el puntero</value>
  </data>
  <data name="Diagnostics" xml:space="preserve">
    <value>Diagnóstico</value>
  </data>
</root>